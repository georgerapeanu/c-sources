#include <cstdio>
#include <iostream>
#include <algorithm>
#include <map>
#include <cmath>
#include <queue>
#include <vector>

using namespace std;

FILE * f = fopen("ccc.in","r");
FILE * g = fopen("ccc.out","w");

const int dx[] = {-1,0,1,0};
const int dy[] = {0,1,0,-1};

struct point_t{
	double x,y,z;
	
	bool operator < (const point_t &other)const{
		if(x != other.x)return x < other.x;
		if(y != other.y)return y < other.y;
		return z < other.z;
	}
	
	point_t(){
		x = y = z =0;
	}
	
	point_t(double x,double y,double z){
		this->x = x;
		this->y = y;
		this->z = z;
	}
	
	double dist(point_t &other){
		return sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y) + (z - other.z) * (z - other.z));
	}

	double ground_dist(point_t &other){
		return sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));
	}
};

struct building_t{
	point_t center;
	vector<point_t > cell_centers;
	
	building_t(double x,double y,double z,vector<point_t > cell_centers = vector<point_t >()){
		this->center = point_t(x,y,z);
		this->cell_centers = cell_centers;
	}
	
	bool operator < (const building_t &other)const{
		return center < other.center;
	}
	
	double dist(building_t &other){
		return center.dist(other.center);
	}
};

const double eps = 1e-5;

int app(double x){
	if(x - (int)x < eps){
		return (int)x - 1;
	}
	return x;
}

building_t bfs(int i,int j,int val,int rows,int cols,vector<vector<int>> &v,vector<vector<int>> &viz){
	queue< pair<int,int> > q;
	vector<point_t > cells;
	viz[i][j] = 1;	
	
	q.push({i,j});
	
	double sx = 0;
	double sy = 0;
	
	int ans = 0;
	
	while(!q.empty()){
		int x = q.front().first;
		int y = q.front().second;
		cells.push_back(point_t(x,y,val));
		sx += x - 0.5;
		sy += y - 0.5;
		ans++;
		q.pop();
		for(int k = 0;k < 4;k++){
			int xx = x + dx[k];
			int yy = y + dy[k];
			if(xx > 0 && xx <= rows && yy > 0 && yy <= cols && v[xx][yy] == val && !viz[xx][yy]){
				viz[xx][yy] = 1;
				q.push({xx,yy});
			}
		}
	}

	sx /= ans;
	sy /= ans;
	
	return building_t(sx,sy,val,cells);
}

int main(){


	int rows;
	int cols;
	int s;
	
	fscanf(f,"%d %d %d\n",&rows,&cols);
	
	point_t site_center(double(rows) / 2,double(cols) / 2,0);
	
	vector<vector<int>> v(rows + 1,vector<int>(cols + 1,0));
	vector<vector<int>> viz(rows + 1,vector<int>(cols + 1,0));
	
	for(int i = 1;i <= rows;i++){
		for(int j = 1;j <= cols;j++){
			fscanf(f,"%d",&v[i][j]);
		}
	}
	
	vector<building_t> surface;
		
	for(int i = 1;i <= rows;i++){
		for(int j = 1;j <= cols;j++){
			if(v[i][j] && !viz[i][j]){
				surface.push_back(bfs(i,j,v[i][j],rows,cols,v,viz));
			}
		}
	}
	
	vector<pair<int,int> > hot;
	
	for(auto it:surface){
		double x1 = 1 << 30;
		double y1 = 1 << 30;
		double x2 = 0;
		double y2 = 0;
		
		for(auto it2:it.cell_centers){
			x2 = max(x2,it2.x);
			x1 = min(x1,it2.x);
			y2 = max(y2,it2.y);
			y1 = min(y1,it2.y);
		}
		
		if(x2 - x1 >= 3 && y2 - y1 >= 3){
			hot.push_back(make_pair(app(it.center.x),app(it.center.y)));
		}
	}
	
	sort(hot.begin(),hot.end());
	
	for(int i = 0;i < (int)hot.size();i++){
		fprintf(g,"%d %d %d ",i,hot[i].first,hot[i].second);
	}
		
	
	fclose(f);
	fclose(g);
	
	return 0;
}