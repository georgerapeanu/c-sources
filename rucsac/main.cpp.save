/*#include <fstream>
#include <algorithm>
using namespace std;
ifstream f("rucsac.in");
ofstream g("rucsac.out");
int i,j,N,G,p[5010],gr[5010];
int D[2][10010];
int maxim;
int main()
{
    f>>N>>G;
    for(i=1;i<=N;i++) f>>gr[i]>>p[i];
    for(i=1;i<=N;i++)
    {
        for(j=1;j<=G;j++)
        {
            if(j<gr[i])
                D[i%2][j]=D[(i-1)%2][j];
            else
                D[i%2][j]=max(D[(i-1)%2][j],D[(i-1)%2][j-gr[i]]+p[i]);
        }
    }
    g<<D[N%2][G];
    f.close();
    g.close();
    return 0;
}*/
// A Dynamic Programming based solution for 0-1 Knapsack problem
#include<stdio.h>

// A utility function that returns maximum of two integers
int max(int a, int b) { return (a > b)? a : b; }

// Returns the maximum value that can be put in a knapsack of capacity W
int knapSack(int W, int wt[], int val[], int n)
{
int i, w;
int K[n+1][W+1];

// Build table K[][] in bottom up manner
for (i = 0; i <= n; i++)
{
	for (w = 0; w <= W; w++)
	{
		if (i==0 || w==0)
			K[i][w] = 0;
		else if (wt[i-1] <= w)
				K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]);
		else
				K[i][w] = K[i-1][w];
	}
}

return K[n][W];
}

int main()
{
	///int val[] = {60, 100, 120};
///	int wt[] = {10, 20, 30};
///	int W = 50;
///	int n = sizeof(val)/sizeof(val[0]);
    int i,N,W;
    int wt[5005],val[5005];
    scanf("%d%d",&N,&W);
    for(i=1;i<=N;i++) scanf("%d %d",&wt[i],&val[i]);
	printf("%d", knapSack(W, wt, val, N));
	return 0;
}
